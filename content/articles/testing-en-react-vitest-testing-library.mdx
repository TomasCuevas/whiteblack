---
author: "Tom√°s Cuevas"
link: "https://www.linkedin.com/in/tom√°s-cuevas-dev/"
title: "Gu√≠a completa para configurar y realizar testing en una aplicaci√≥n de React."
date: "2023-06-10"
description: "Descubre c√≥mo configurar y realizar testing efectivos en aplicaciones de React utilizando Vitest y Testing Library. En este art√≠culo, aprender√°s las mejores pr√°cticas para mejorar la calidad de tu c√≥digo, asegurar la robustez y eficiencia de tus componentes React."
cardDescription: "Los __tests__ son una parte fundamental en el desarrollo de aplicaciones en __React.js__ y en la construcci√≥n de componentes. Los tests son esenciales para garantizar la _calidad, confiabilidad y mantenibilidad_ de nuestras aplicaciones en React y los componentes que construimos. Nos ayudan a _identificar y corregir errores_, _mejorar el c√≥digo_ y brindar una base s√≥lida para el desarrollo y la colaboraci√≥n en equipo."
category: "react"
tags:
  - "react"
  - "testing"
  - "vitest"
  - "testing-library"
  - "jsdom"
keywords: "React, Vitest, Testing Library, pruebas unitarias, testing, desarrollo de software, aplicaciones web, JavaScript, bibliotecas de pruebas, componentes React, Jest, jsdom, entorno de pruebas, configuraci√≥n de pruebas, pruebas de rendimiento, mejores pr√°cticas de pruebas, calidad de c√≥digo,desarrollo web, frameworks JavaScript."
---

<Section>
## Introducci√≥n

El `testing` es una parte fundamental en el desarrollo de aplicaciones en `React.js` y en la construcci√≥n de componentes. Los `tests` son esenciales para garantizar la _calidad, confiabilidad y mantenibilidad_ de nuestras aplicaciones en React y los componentes que construimos. Nos ayudan a _identificar y corregir errores_, _mejorar el c√≥digo_ y brindar una base s√≥lida para el desarrollo y la colaboraci√≥n en equipo.

</Section>

<Section>
## Beneficios de realizar pruebas en nuestras aplicaciones

- **Confianza en el c√≥digo**: Los `tests` nos brindan confianza al asegurar que nuestro c√≥digo funcione como se espera. Nos permiten validar el comportamiento de nuestros componentes y asegurarnos de que sigan funcionando correctamente incluso despu√©s de cambios o actualizaciones.
- **Identificaci√≥n de errores**: Los `tests` nos ayudan a detectar errores y `bugs` en nuestras aplicaciones y componentes de manera temprana. Al escribir pruebas exhaustivas, podemos identificar y corregir problemas antes de que lleguen a `producci√≥n`, lo que nos ahorra tiempo y evita posibles problemas para los usuarios.
- **Mantenimiento del c√≥digo**: Los `tests` act√∫an como una l√≠nea de defensa al `refactorizar` o modificar el c√≥digo existente. Al tener pruebas en su lugar, podemos realizar cambios con mayor `seguridad`, ya que las pruebas nos alertar√°n si algo se ha roto durante el proceso de refactorizaci√≥n.
- **Facilita la colaboraci√≥n**: Los `tests` proporcionan un medio para `colaborar eficientemente` en el desarrollo de software. Al compartir pruebas, los miembros del equipo pueden entender r√°pidamente el comportamiento esperado y pueden realizar cambios o mejoras sin temor a romper la funcionalidad existente.

</Section>

<Section>
## Instalaciones y configuraciones necesarias

</Section>

<Section>
### Iniciar un proyecto de React con Vite

Para empezar, es necesario tener una aplicaci√≥n de `React`. Puedes crear una f√°cilmente utilizando el `siguiente comando` en tu terminal:

```sh
npm create vite
```

Se te pedir√° que ingreses un `nombre` para tu proyecto y luego elijas el `framework/biblioteca` que deseas utilizar. En este caso, seleccionaremos `React`. Tambi√©n se te preguntar√° si deseas utilizar `TypeScript` o simplemente `JavaScript`. En este art√≠culo, vamos a configurar un proyecto de React con `JavaScript`. Una vez hecho esto, debes navegar hacia la carpeta del proyecto y ejecutar el siguiente comando para instalar las dependencias necesarias:

```sh
npm install
```

</Section>

<Section>
### Instalar vitest, @testing-library/react y jsdom

Para realizar `testing` en aplicaciones de `React`, es necesario instalar las siguientes bibliotecas como dependencias en nuestro proyecto: `vitest`, `testing-library/react` y `jsdom`. Estas bibliotecas combinadas ofrecen un conjunto de herramientas poderosas para llevar a cabo pruebas efectivas en nuestras aplicaciones React.

- **Vitest**: Es una biblioteca de pruebas unitarias para JavaScript. Proporciona un conjunto de utilidades y funciones que permiten escribir pruebas concisas y efectivas para el c√≥digo JavaScript
- **Testing-Library/React**: Esta biblioteca se centra en las pruebas de componentes React. Proporciona una serie de utilidades para interactuar con componentes React y realizar aserciones sobre su comportamiento y apariencia.
- **JSDOM**: Es una biblioteca que simula un entorno DOM (Document Object Model) en Node.js. Permite ejecutar y probar c√≥digo JavaScript que interact√∫a con el DOM sin necesidad de un navegador real. JSDOM proporciona una API que imita la API del DOM en el navegador

Todas estas `dependencias` son de `desarrollo`, lo que significa que no son necesarias para que nuestro proyecto se ejecute correctamente. Por lo tanto, al instalarlas, debemos utilizar el siguiente comando junto con la "bandera" `-D` para indicar que son dependencias de desarrollo:

```sh
npm install -D vitest testing-library/react jsdom
```

</Section>

<Section>
### Configurar jsdom

Cuando creamos un proyecto de React con Vite, se genera autom√°ticamente un archivo llamado `vite.config.js` donde se encuentran todas las configuraciones de `Vite`. En este archivo, debemos agregar una nueva propiedad para indicar que se debe utilizar la biblioteca `JSDOM` cuando se realicen las pruebas. Por lo tanto, el archivo `vite.config.js` deber√≠a tener la siguiente estructura:

> vite.config.js

```js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    globals: true,
  },
});
```

Agregamos la propiedad `test`, que contiene un objeto con las propiedades `environment` y `globals`. De esta manera, indicamos que se debe utilizar el entorno de `jsdom` y habilitar las `variables globales` en las pruebas, como `window` o `document`.

</Section>

<Section>
### Agregar script en package.json para ejecutar los tests

Para configurar la ejecuci√≥n de todos los `tests` en nuestro proyecto, es necesario agregar un `script` en el archivo `package.json`. En la secci√≥n de `scripts`, podemos a√±adir la propiedad `"test"` con el valor `"vitest"` de la siguiente manera:

> package.json

```json
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint src --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "test": "vitest" // nuevo script
  },
```

Al incluir esta configuraci√≥n, podemos ejecutar todos los tests de nuestro proyecto utilizando el comando `npm run test` en la terminal. Esto disparar√° la ejecuci√≥n de los tests y mostrar√° los resultados correspondientes.

Al utilizar `npm run test`, se ejecutar√° la herramienta `Vitest` y comenzar√° a ejecutar todos los `tests` disponibles en el proyecto. Esto proporciona una forma sencilla y conveniente de realizar pruebas automatizadas y verificar la integridad de nuestro c√≥digo.

</Section>

<Section>
## Configuraciones y explicaciones de Vitest

</Section>

<Section>

### Componente al cual le haremos testing

En este art√≠culo, vamos a realizar pruebas en un componente de tipo "acorde√≥n". Un `acorde√≥n` es un `componente` com√∫n en el que se muestra un subt√≠tulo y, al hacer clic en √©l, se revela el contenido oculto. Al hacer clic nuevamente, se vuelve a ocultar el contenido.

Durante el `testing`, nos aseguraremos de verificar el comportamiento esperado del acorde√≥n, es decir, que se muestre el contenido oculto al hacer clic en el subt√≠tulo y que se oculte nuevamente al hacer clic una vez m√°s.

> Accordion.jsx

```jsx
import { useState } from "react";

//* icons *//
import { ArrowDown, ArrowUp } from "./icons";

//* styles *//
import Styles from "./Accordion.module.css";

export const Accordion = ({ children, title }) => {
  const [open, setOpen] = useState(false);

  return (
    <article
      role="accordion"
      onClick={() => setOpen((prevValue) => !prevValue)}
      className={Styles.accordion__card}
    >
      <div className={Styles.accordion__header}>
        <h3 className={Styles.accordion__title}>{title}</h3>
        {open ? <ArrowUp /> : <ArrowDown />}
      </div>

      {open ? (
        <div role="content" className={Styles.accordion__content}>
          <div className={Styles.accordion__more}>{children}</div>
        </div>
      ) : null}
    </article>
  );
};
```

Este componente recibe dos propiedades: `children` y `title`. La propiedad children representa el contenido oculto del acorde√≥n, mientras que title representa el subt√≠tulo del acorde√≥n. Adem√°s, dentro del componente, se utiliza un estado controlado por el hook `useState` para indicar si el acorde√≥n est√° _abierto o cerrado_. Este estado cambia cuando se hace clic en el acorde√≥n.

Adem√°s, se asigna el atributo `role` a la etiqueta `article` y a la etiqueta `div` que envuelve la propiedad children. Cada uno de ellos tiene un valor diferente. Al utilizar el atributo `role` en los elementos, facilitamos la identificaci√≥n y selecci√≥n espec√≠fica de los elementos durante el `testing`.

</Section>

<Section>
### Convenci√≥n de nombres para los archivos de testing

Los archivos de testing, deben seguir una `convenci√≥n de nomenclatura` similar al nombre del componente al que hacen referencia. En este caso, se debe anteponer el sufijo `.test` al nombre del componente y luego mantener la extensi√≥n de archivo correspondiente. Por lo tanto, el archivo de pruebas para `Accordion.jsx` se llamar√≠a `Accordion.test.jsx`.

```text
‚îú‚îÄ üìÅ accordion
|  ‚îú‚îÄ üñáÔ∏è Accordion.jsx
|  ‚îú‚îÄ üñáÔ∏è Accordion.test.jsx
```

</Section>

<Section>
### Importaciones necesarias para realizar nuestros tests

El archivo de prueba comienza importando las funciones necesarias para los tests, como `beforeEach`, `describe`, `expect` y `test`, de la biblioteca `Vitest`. Tambi√©n se importan las funciones `fireEvent`, `render` y `screen` de la biblioteca `Testing-Library/React`.

> Accordion.test.jsx

```jsx
import { beforeEach, describe, expect, test } from "vitest";
import { fireEvent, render, screen } from "@testing-library/react";
```

</Section>

<Section>
### Funci√≥n describe de Vitest

Todos los `tests` estar√°n contenidos dentro de una funci√≥n llamada `describe`. Esta funci√≥n se utiliza para _agrupar y organizar_ los tests relacionados en bloques. Proporciona un _contexto y una descripci√≥n_ para los tests que se encuentran dentro de √©l. La funci√≥n `describe` recibe dos argumentos: un `string` que se utiliza para _describir las pruebas_ que se encuentran dentro de √©l y una `funci√≥n` que _contendr√° todos los tests_.

> Accordion.test.jsx

```jsx
import { beforeEach, describe, expect, test } from "vitest";
import { fireEvent, render, screen } from "@testing-library/react";

describe("Testing sobre el componente Accordion.jsx", () => {
  // Todos los tests van aqu√≠
});
```

</Section>

<Section>
### Funci√≥n beforeEach y render de Vitest

Antes de cada test, se utiliza la funci√≥n `beforeEach` en combinaci√≥n con la funci√≥n `render` de `Vitest` para realizar configuraciones previas y renderizar el componente con valores predefinidos. En este caso, se establece la propiedad `title` con el valor `"M√°s informaci√≥n"` y se incluye un `p√°rrafo (<p>)` dentro del componente, representando as√≠ la propiedad `children` del componente. Para todo ello, primero debemos importar el componente `Accordion` al archivo de test.

Esta configuraci√≥n previa nos permite establecer un `estado inicial` com√∫n para todos los tests, evitando la duplicaci√≥n de c√≥digo y simplificando el proceso de escritura de los tests.

> Accordion.test.jsx

```jsx
import { beforeEach, describe, expect, test } from "vitest";
import { fireEvent, render, screen } from "@testing-library/react";

import { Accordion } from "./Accordion";

describe("Testing sobre el componente Accordion.jsx", () => {
  beforeEach(() => {
    render(
      <Accordion title="M√°s informaci√≥n">
        <p>
          Duis velit pariatur labore reprehenderit velit nisi nostrud laboris
          proident eu veniam sit in.
        </p>
      </Accordion>
    );
  });
});
```

</Section>

<Section>
### Funci√≥n test de Vitest

La funci√≥n `test` se utiliza para definir tests individuales dentro de un bloque `describe` y verificar el comportamiento esperado de un componente o una funcionalidad espec√≠fica. Dentro de la funci√≥n `test`, se puede escribir c√≥digo para simular _interacciones_ o _eventos_, _invocar funciones_ y _realizar comprobaciones_ utilizando las funciones de aserci√≥n proporcionadas por `Vitest`, como `expect`.

La funci√≥n `test` recibe dos argumentos: una `string` que describe el test y una `funci√≥n` que contiene la l√≥gica de la prueba.

> Accordion.test.jsx

```jsx
import { beforeEach, describe, expect, test } from "vitest";
import { fireEvent, render, screen } from "@testing-library/react";

import { Accordion } from "./Accordion";

describe("Testing sobre el componente Accordion.jsx", () => {
  beforeEach(() => {
    render(
      <Accordion title="M√°s informaci√≥n">
        <p>
          Duis velit pariatur labore reprehenderit velit nisi nostrud laboris
          proident eu veniam sit in.
        </p>
      </Accordion>
    );
  });

  test("Descripci√≥n acerca del test que se ejecuta aqu√≠", () => {
    // Log√≠ca del test
  });
});
```

</Section>

<Section> 
## Ejemplos de pruebas usando Vitest

</Section>

<Section>
### Test: Mostrar el t√≠tulo todo el tiempo

El primer `test` se enfoca en verificar si el t√≠tulo del componente `Accordion.jsx` se muestra correctamente en todo momento. Para esto, se utiliza la funci√≥n `expect` junto con la funci√≥n `getByText` de la biblioteca `@testing-library/react` para buscar el texto _"M√°s informaci√≥n"_ en la interfaz.

En este `test`, se utiliza la funci√≥n `expect` para realizar una afirmaci√≥n sobre el resultado esperado. La funci√≥n `screen.getByText` se encarga de seleccionar el elemento que contiene el texto espec√≠fico, en este caso, _"M√°s informaci√≥n"_, dentro del componente Accordion que ha sido renderizado previo al test en la funci√≥n `beforeEach`. Luego, se utiliza la funci√≥n `toBeDefined` para verificar que el elemento existe, confirmando as√≠ que el t√≠tulo se muestra correctamente.

> Accordion.test.jsx

```jsx
describe("Testing sobre el componente Accordion.jsx", () => {
  beforeEach(() => {
    render(
      <Accordion title="M√°s informaci√≥n">
        <p>
          Duis velit pariatur labore reprehenderit velit nisi nostrud laboris
          proident eu veniam sit in.
        </p>
      </Accordion>
    );
  });

  test("Debe mostrar el t√≠tulo todo el tiempo.", () => {
    expect(screen.getByText("M√°s informaci√≥n")).toBeDefined();
  });
});
```

</Section>

<Section>
### Test: Mostrar el contenido cuando el acorde√≥n es cliqueado

Este `test` se encarga de verificar si el contenido del acorde√≥n se muestra correctamente cuando se realiza un `clic` en √©l. Para lograr esto, se utilizan las funciones `fireEvent.click`, `screen.getByRole` y `screen.queryByRole`.

En el `test`, se obtiene una referencia al acorde√≥n utilizando `screen.getByRole` y el atributo _"accordion"_. A continuaci√≥n, se dispara un evento de clic en el acorde√≥n utilizando `fireEvent.click(accordion)`. Despu√©s, se busca el contenido del acorde√≥n utilizando `screen.queryByRole` y el atributo _"content"_. Por √∫ltimo, se utiliza la funci√≥n `expect` junto con `toBeTruthy` para verificar si el contenido del acorde√≥n existe y es visible en la interfaz.

> Accordion.test.jsx

```jsx
describe("Testing sobre el componente Accordion.jsx", () => {
  beforeEach(() => {
    render(
      <Accordion title="M√°s informaci√≥n">
        <p>
          Duis velit pariatur labore reprehenderit velit nisi nostrud laboris
          proident eu veniam sit in.
        </p>
      </Accordion>
    );
  });

  test("Debe mostrar el contenido cuando el acorde√≥n es cliqueado", () => {
    const accordion = screen.getByRole("accordion");
    fireEvent.click(accordion);

    const accordionContent = screen.queryByRole("content");
    expect(accordionContent).toBeTruthy();
  });
});
```

</Section>

<Section>
### Test: Ocultar contenido al hacer clic en el acorde√≥n previamente clicado

Tiene como objetivo verificar si el contenido del acorde√≥n se oculta correctamente cuando se hace `clic` en el acorde√≥n despu√©s de haber sido previamente clicado. Este test utiliza las funciones `fireEvent.click`, `screen.getByRole` y `screen.queryByRole`.

En este `test`, se obtiene una referencia al acorde√≥n utilizando `screen.getByRole` y el atributo _"accordion"_. Luego, se simulan dos `clics` consecutivos en el acorde√≥n utilizando `fireEvent.click(accordion)`. Despu√©s de los clics, se busca el contenido del acorde√≥n utilizando `screen.queryByRole` y el atributo _"content"_. Por √∫ltimo, se utiliza la funci√≥n `expect` junto con `toBeNull` para verificar si el contenido del acorde√≥n no est√° presente en la interfaz.

> Accordion.test.jsx

```jsx
describe("Testing sobre el componente Accordion.jsx", () => {
  beforeEach(() => {
    render(
      <Accordion title="M√°s informaci√≥n">
        <p>
          Duis velit pariatur labore reprehenderit velit nisi nostrud laboris
          proident eu veniam sit in.
        </p>
      </Accordion>
    );
  });

  test("Debe ocultar el contenido cuando se haga clic en el acorde√≥n cuando este ya ha sido cliqueado previamente", () => {
    const accordion = screen.getByRole("accordion");

    fireEvent.click(accordion);
    fireEvent.click(accordion);

    const accordionContent = screen.queryByRole("content");
    expect(accordionContent).toBeNull();
  });
});
```

</Section>

<Section>
## Conclusi√≥n

El `testing` es una pr√°ctica fundamental en el desarrollo de aplicaciones en `React.js`. Proporciona una manera de garantizar la _calidad, confiabilidad y mantenibilidad_ de nuestras _aplicaciones y componentes_. A trav√©s de las pruebas, podemos `identificar` y `corregir errores`, mejorar el c√≥digo y brindar una base s√≥lida para el desarrollo y la colaboraci√≥n en equipo.

En este art√≠culo, hemos explorado c√≥mo `configurar` y realizar pruebas efectivas en una aplicaci√≥n de React utilizando `Vitest` y `Testing Library`. Aprendimos c√≥mo instalar y configurar las dependencias necesarias, c√≥mo realizar pruebas sobre un componente de `React` y c√≥mo utilizar las funciones y herramientas proporcionadas por `Vitest` y `Testing Library` para simular interacciones, invocar funciones y realizar comprobaciones.

Es importante destacar que este art√≠culo solo `raspa la superficie` del mundo del testing en `React`. Hay muchas m√°s `t√©cnicas` y `estrategias` avanzadas que se pueden explorar para lograr una cobertura de pruebas m√°s completa y eficaz. Recomiendo encarecidamente seguir aprendiendo y explorando m√°s sobre el tema, ya que el `testing` es una habilidad _valiosa y altamente demandada_ en el desarrollo de software.

</Section>
